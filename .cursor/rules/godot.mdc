# Godot Development Rules

globs: godot/\*\*

## Core Development Guidelines

- Use strict typing in GDScript for better error detection and IDE support
- Implement \_ready() and other lifecycle functions with explicit super() calls
- Use @onready annotations instead of direct node references in \_ready()
- Prefer composition over inheritance where possible
- Use signals for loose coupling between nodes

## Code Style

- Use type hints for all variables and function parameters
- Document complex functions with docstrings
- Keep methods focused and under 30 lines when possible
- Use meaningful variable and function names
- Group related properties and methods together

## Naming Conventions

- Files: snake_case for all filenames (e.g., player_character.gd, main_menu.tscn)
- Classes: PascalCase for custom class names with class_name (e.g., PlayerCharacter)
- Variables: snake_case for all variables including member variables (e.g., health_points)
- Constants: ALL_CAPS_SNAKE_CASE for constants (e.g., MAX_HEALTH)
- Functions: snake_case for all functions including lifecycle functions (e.g., move_player())
- Enums: PascalCase for enum type names and ALL_CAPS_SNAKE_CASE for enum values
- Nodes: PascalCase for node names in the scene tree (e.g., PlayerCharacter, MainCamera)
- Signals: snake_case in past tense to name events (e.g., health_depleted, enemy_defeated)

## Scene Organization

- Keep scene tree depth minimal for better performance
- Use scene inheritance for reusable components
- Implement proper scene cleanup on queue_free()
- Use SubViewport nodes carefully due to performance impact
- Provide step-by-step instructions to create Godot scene(s) instead of providing scene source code

## Signal Best Practices

- Use clear, contextual signal names that describe their purpose (e.g., player_health_changed)
- Utilize typed signals to improve safety and IDE assistance (e.g., signal item_collected(item_name: String))
- Connect signals in code for dynamic nodes, and in the editor for static relationships
- Avoid overusing signals - reserve them for important events, not frequent updates
- Pass only necessary data through signal arguments, avoiding entire node references when possible
- Use an autoload "EventBus" singleton for global signals that need to reach distant nodes
- Minimize signal bubbling through multiple parent nodes
- Always disconnect signals when nodes are freed to prevent memory leaks
- Document signals with comments explaining their purpose and parameters

## Resource Management

- Implement proper resource cleanup in \_exit_tree()
- Use preload() for essential resources, load() for optional ones
- Consider PackedByteArray storage impact on backwards compatibility
- Implement resource unloading for unused assets

## Performance Best Practices

- Use node groups judiciously for managing collections
- Prefer direct node references for frequent, specific access to individual nodes
- Implement object pooling for frequently spawned objects
- Use physics layers to optimize collision detection
- Prefer packed arrays (PackedVector2Array, etc.) over regular arrays

## Error Handling

- Implement graceful fallbacks for missing resources
- Use assert() for development-time error checking
- Log errors appropriately in production builds
- Handle network errors gracefully in multiplayer games

## Testing and Validation

- **After making code changes**: Run `./cursor-integration/godot-check-errors.sh` to check for runtime errors and warnings in the Godot log file
- The error check script should be run as part of testing after any code modifications to catch issues early
- The script checks the latest Godot log file and reports any errors or warnings found
- This helps catch runtime issues that may not be detected during static analysis
- Run the script from the project root: `./cursor-integration/godot-check-errors.sh`
- The script will automatically find the Godot log file at `~/.local/share/godot/app_userdata/Furnace/logs/godot.log`

## Real-Time Error Monitoring

- **Godot Log Watcher**: A real-time error monitoring system is available in `cursor-integration/`
- **Cross-Platform**: Works on Linux, macOS, and Windows
- **Setup**: Start the watcher before running Godot:
  
  **Linux/macOS:**
  ```bash
  cd cursor-integration
  ./godot-dev.sh start
  ```
  
  **Windows (PowerShell):**
  ```powershell
  cd cursor-integration
  .\godot-dev.ps1 start
  ```
  
  **Windows (Git Bash):**
  ```bash
  cd cursor-integration
  ./godot-dev.sh start
  ```
- **How It Works**: 
  - Automatically finds Godot log files (searches `~/.local/share/godot/app_userdata/Furnace/logs/`)
  - Monitors log files for errors and warnings in real-time using `inotifywait`
  - Parses multiple Godot error formats (ERROR/WARNING messages, stack traces, compilation errors)
  - Sends formatted errors to Cursor via temporary files or clipboard
- **Usage**:
  - `./godot-dev.sh start` - Start the watcher (runs in background)
  - `./godot-dev.sh status` - Check if watcher is running
  - `./godot-dev.sh stop` - Stop the watcher
  - `./godot-dev.sh log` - View watcher output
  - `./godot-dev.sh find-log` - Locate the current log file
- **Error Detection**: The system detects:
  - Script errors (missing nodes, type mismatches, null references)
  - Resource loading failures
  - Signal connection issues
  - Compilation errors
  - Stack traces with file paths and line numbers
- **Integration**: Errors are automatically formatted and sent to Cursor for easy debugging
- **Cursor CLI Support**: Automatically detects and uses Cursor CLI (`cursor`, `cursor.exe`, or `cursor.cmd`) to open error files directly
- **Dependencies**: 
  - Linux: Requires `inotify-tools` package (`sudo pacman -S inotify-tools` on Arch, `sudo apt-get install inotify-tools` on Ubuntu)
  - Windows: PowerShell 5.1+ (built-in) or Git Bash with WSL
  - macOS: `fswatch` via Homebrew or use bash scripts
- **Note**: The watcher will wait for Godot to create log files if they don't exist yet - just start Godot and the watcher will automatically detect them

## TileMap Implementation

- TileMap node is deprecated - use multiple TileMapLayer nodes instead
- Convert existing TileMaps using the TileMap bottom panel toolbox option "Extract TileMap layers"
- Access TileMap layers through TileMapLayer nodes
- Update navigation code to use TileMapLayer.get_navigation_map()
- Store layer-specific properties on individual TileMapLayer nodes

## Web Export Considerations

- Use set_deferred() for physics property changes (monitoring, monitorable, collision layers)
- Store JavaScript bridge callbacks in meta to prevent garbage collection
- Test web builds frequently during development
- Use GL Compatibility renderer for web export
